#
#---
# Copyright (c) 2014 EM-MicroElectronic-Marin SA. All Rights Reserved.
# <br>Developed by Glacier River Design, LLC.
#---
#
module BeaconTools


##
# Memory interface to records from an IntelHexFile
#
# =RESPONSIBILITY
# * Model the data for each record type of an Intel Hex File.
# * Permit data access (both read & write) by memory address.
# * Record creation and propagation of offsets to a sequence of records
# * Verify that sets of records describe a contiguous address space.
#
# =COLLABORATION
# Data encapsulation class aggregated by IntelHexFile which manages intra-record
# dependence on memory offsets to maintain correct memory addresses.
#
# =NOTE
# Code in HexRecord and IntelHexFile classes relied on information in the
# wikipedia article at https://en.wikipedia.org/wiki/Intel_HEX.  Hex files
# generated by the GCC linker in the current Ride7 release appear only use
# record types 00, 01, 02, 04 and 05.

class HexRecord

   # @return [Fixnum] starting memory address of data in the record
   attr_reader :memaddr

   # @return [String] two-byte record type
   attr_reader :type

   # @return [String] Hexadecimal digit string representation of the datra
   attr_reader :data

   ##
   # Create a new instance of a HexRecord using data from an Intel Hex File
   #
   # @param [String] file_data a line with any record type from an Intel Hex file
   #
   # @return nothing

   def initialize(file_data)
      raise "Bad Hex File Format" unless file_data[0] == ":"
      raise "Bad Record Length"   unless file_data.size == 11 + 2 * file_data[1..2].to_i(16)
      @length  = file_data[1..2]   # length _in bytes_ (as hex digit string) of the data field
      @address = file_data[3..6]
      @memaddr = @address.to_i(16)
      @type    = file_data[7..8]
      @data    = file_data[9..-3]  # assert @data.size == @length
      error_descriptor = "Bad Record CheckSum #{file_data[-2..-1]}, got #{checksum}"
      raise error_descriptor unless file_data[-2..-1] == checksum
   end

   ##
   # Supplemental method for data records (type 00) so we can accurately know the
   # proper memory space where the data resides in the device flash.
   #
   # @param [String] offset Base address from which the record address is offset. Spccified by
   #            the intex hex file format, this value is defined in offset records
   #            that do not carry any memory content.
   # @param [String] type Record type in which the offset was defined. This tells us how the
   #            offset was formatted to fit a 16-bit representation.
   #
   # @return self

   def add_offset(offset, type)
      if type == "02"
         # Extended Segment Address Record: shift 4 bits left by appending a "0"
         offset += "0"
      elsif type == "04"
         # Extended Linear Address Record: shift 16 bits left by appending "0000"
         offset += "0000"
      else
         raise "unexpected offset record type #{type}"
      end
      @memaddr += offset.to_i(16)
      self
   end

   ##
   # Calculates the record-relative BYTE offset of the data specified by an address.
   #
   # ===Example:
   # Given a record whose data starts at address 0x014220 and an input address
   # 0x01423A, the offset that would be returned is (in decimal) 26---provided
   # the record had at least 27 bytes (54 hex digits worth) of data. If not,
   # the return value would be nil, instead.
   #
   # @param [String,Fixnum] address memory location represented by a string of
   #        hexadecimal digits or by a numeric value.
   #
   # @return [Fixnum] _byte_ offset, not a hex digit offset, to the data specified by
   #   the input address OR nil if the addressed byte is not in the record's
   #   address space. (Since the data is represented as a string of hex digits
   #   each byte takes two characters. The return value must be multiplied by
   #   two if it is to be used as an index into the data.)

   def get_byte_offset(address)
      address = address.to_i(16) if address.is_a? String
      (address < @memaddr || address >= @memaddr + @length.to_i(16)) ? nil : (address - @memaddr)
   end

   ##
   # Predicate on whether a record contains data in the specified memory region.
   #
   #
   # @param [String,Fixnum] address the starting byte address of the memory region of interest
   # @param [String,Fixnum] length  the number of bytes (not hex digits) in the region
   #
   # @return [boolean] true when a HexRecord holds ANY bytes in the region; otherwise false.

   def contains?(address, length)

      return false unless @type == "00"  # i.e., unless it's a DATA record

      region_start =  address.is_a?(String) ? address.to_i(16) : address
      region_stop  = ( length.is_a?(String) ?  length.to_i(16) : length) + region_start

      hex_record_start = @memaddr
      hex_record_stop  = @memaddr + @length.to_i(16)

      # Negate this: "ALL the record's data comes before the region OR
      #               ALL the record's data comes after  the region"
      !(hex_record_stop <= region_start || hex_record_start >= region_stop)
   end

   ##
   # compute the checksum value and represent it as a two-byte string of hex digits
   #
   # @param none
   #
   # @return [String] the checksum value as a string of two hexadecimal digits

   def checksum
      hex_seq = @length + @address + @type + @data

      # Next statement converts a sequence of hex digits (a String) into an array of numbers
      # representing numeric values of the corresponding byte sequence members.
      byte_seq = Hex.digits_to_byte_seq hex_seq
      cksum = 0 - byte_seq.reduce {|sum, byte| sum + byte}  # form sum & 2's complement
      cksum = (0xFF & cksum).to_s(16).upcase                # convert back to hex String
      cksum.length < 2 ? "0" + cksum : cksum                # prepend leading "0" if needed
   end

   ##
   # Cannonical Ruby "to string" converter for hex records: transforms them into the
   # format used for lines of an Intel hex file.
   #
   # @param none
   #
   # @return [String] the record formatted in Intex hex file fashion

   def to_s
      ":" + @length + @address + @type + @data + checksum
   end


   ##
   # Indexed memory read from the flash address space of a device described by a
   # single record of (i.e., line in) an Intel Hex file used to program that device.
   #
   # @param [Fixnum] read_address address lying within the record's local address space
   # @param [Fixnum] length_in_bytes numeric count of "bytes" to return
   #
   # @return nil if there are errors (requested address is out of bounds); otherwise
   #   a string containing twice as many characters as the number of bytes
   #   requested. Each byte is represented as two characters in the string having
   #   values in the set matching [A-Fa-f0-0]

   def [](read_address, length_in_bytes)
      return nil if read_address < @memaddr
      return nil if read_address + length_in_bytes > @memaddr + @data.size/2
      @data[2*(read_address - @memaddr), 2*length_in_bytes]
   end

   ##
   # Record content (data) update modeled as an indexed memory write to the flash
   # address space of a device described by a single record of (i.e., line in) an
   # Intel Hex file used to program that device.
   #
   # @param [Fixnum] write_address address in the hex record's address space.
   # @param [String] hex_data a sequence of 1 or more bytes as pairs of hexadecimal digits.
   #
   # @return nothing
   #
   # @raise [RuntimeError] for all address and data error conditions.

   def []=(write_address, hex_data)
      puts "in RecWriteMem, addr [#{write_address.to_s(16)}] and data [#{hex_data}]" if $debug
      puts "             memaddr [#{@memaddr.to_s(16)}] and size [#{data.size/2}]"   if $debug
      puts "         before data [#{@data}]" if $debug
      raise "RecWriteError: Odd umber of digits"   unless hex_data.size % 2 == 0
      raise "RecWriteError: Non-hexadecimal data"  unless /^[0-9A-Fa-f]+$/ =~ hex_data
      raise "RecWriteError: Address below lower bound" if write_address < @memaddr
      raise "RecWriteError: Address above upper " +
            "bound" if write_address + hex_data.size/2 > @memaddr + @data.size/2
      @data[2*(write_address - @memaddr), hex_data.size] = hex_data
      puts "          after data [#{@data}]" if $debug
   end

   ##
   # Predicate: The array of HexRecords covers a contiguous
   # address space with no missing and no overlapped regions?
   #
   # ===Notes:
   # 1. A single (type: data) HexRecord is contiguous by definition.
   # 2. The caller _must_ ensure the records are in ascending base address order
   #
   # @param [Array of HexRecord] rec_array an iterable collection of HexRecord
   # @return [boolean] true if the region is contiguous as described above; otherwise, false.
   # @raise ArgumentError unless rec_array is a non-empty array of HexRecord

   def self.contiguous?(rec_array)
      raise ArgumentError unless rec_array.size > 0 && rec_array[0].kind_of?(HexRecord)

      # Establish loop preconditions (first block IS contiguous and mem_address
      # points to end of contiguous region), then walk through the list starting
      # with the second record to confirm that their memory boundaries (end of
      # the previous record and the beginning of the next) exactly agree.
      #
      contiguous  = true
      mem_address = rec_array[0].memaddr + rec_array[0].data.size/2

      rec_array[1..-1].each do |rec|
         raise ArgumentError unless rec.kind_of? HexRecord
         contiguous  &&= mem_address == rec.memaddr  # matches start of this block?
         contiguous  ||  break
         mem_address +=  rec.data.size / 2           # compute end of the this block
      end
      contiguous
   end

end  # class HexRecord


##
# A Serializable & Deserializable Read/Write Memory
#
# =RESPONSIBILITY:
# Serialization and deserialization of Intel Hex files. Provides read and write
# access via memory addresses abstracting the underlying record structure. Tracks
# inter-record dependencies during construction so that memory offsets are known
# by each data record.
#
# =COLLABORATION:
# Aggregates HexRecord objects, one to represent each line of the hex file and to
# provide access and update capabilities for the encapsulated data.
#
# =NOTE:
# It's modeled as a memory because it supports two operations, indexed read using
# the "[]" (access) operator and indexed write using the "[]=" (assignment) operator.
# Both use a flash memory address for the index, one returning and the other updating
# the associated data.

class IntelHexFile

   ## @return path to intel hex file used for deserialization
   attr_reader :file_path

   ##
   # Create an instance of IntelHexFile without any HexRecords (see deserialize and
   # the "<<" methods).
   #
   # @param [Hash] requirements: provides :offsets key with boolean value. If true,
   #           offset record values are added to addresses; otherwise they are simply
   #           deserialized and serialized. The primary use for setting this true is
   #           if the addresses to be accessed come from a memory map file.
   # @return nothing

   def initialize(requirements)
      # Prepare an instance for addition of HexRecord(s) via read or append methods
      @records   = []
      @type2_offset = "0x00"
      @type4_offset = "0x00"
      @use_offsets  = requirements[:offsets]
      @unprotected  = nil    # default semantics: the whole of flash is write-protected
   end

   ##
   # Read (deserialize) and analyze each line of an Intel hex file.
   # See https://en.wikipedia.org/wiki/Intel_HEX for details of the record types.
   # These types are analyzed by the case statement central to this function.
   # Basically, addresses given by data records are relative to the offsets given
   # by other record types. Resolving map file addresses depends on absolute memory
   # addresses calculated by adding offsets the relative addresses in the data
   # record types.
   #
   # @param [String] file_name path w/ file name for the .hex file to deserialize
   #
   # @return self

   def deserialize(file_path)
      File.open(file_path) do |hex_file|
         hex_file.each_line do |line|
            hex_rec = HexRecord.new line.chomp
            if @use_offsets
               case hex_rec.type
                  when "00"
                     # Expects that, at most, one type of offset will be non-zero
                     hex_rec.add_offset @type2_offset, "02"
                     hex_rec.add_offset @type4_offset, "04"
                  when "02"
                     @type2_offset = hex_rec.data
                  when "04"
                     @type4_offset = hex_rec.data
               end # case
            end
            @records << hex_rec
            break if hex_rec.type == "01"
         end
      end
      self
   end

   ##
   # Serialize the internal collection of hex records to a text file.
   #
   # @param [String] file_path Path for the .hex file to which the data is serialized.
   #   Must include file name.
   #
   # @return self

   def serialize(file_path)
      raise "No records to serialize" unless @records.size > 0
      File.open(file_path, "w") do |hex_file|
         @records.each do |hex_rec|
            hex_file.puts hex_rec    # note, implicit use of to_s
         end
      end
      self
   end

   ##
   # Defines an unprotected areas that permits write access
   # For now, at least, only one such area can be defined (at a time).
   #
   # @param [String or Fixnum] start, address of the first byte that is unprotected
   # @param [String or Fixnum] stop,  address of the last  byte that is unprotected
   #
   # @return self

   def allow_writes_to(start, stop)
      start = start.to_i(16) if start.kind_of? String
      stop  = stop.to_i(16)  if stop.kind_of?  String
      @unprotected = {start: start, stop: stop}
   end

   ##
   # Memory read: return a string of hex digits (two digits per byte requested).
   #
   # @param [String,Fixnum] byte_address Memory address in numeric or hex string format
   # @param [String,Fixnum] byte_count   Length, in numeric or hex string format, of data to return
   #    in bytes, NOT the length in digits!
   #
   # @return String of hex digits---two per requested byte---that represents the data
   #   stored at the address given by byte_address.

   def [](byte_address, byte_count)
      puts "In MemRead: address [#{byte_address}], length [#{byte_count}]" if $debug

      # aggregate *all* data from the hex records involved
      #
      # Note, the following code works and it's arguably easier to understand, but
      # it violates the encapsulation provided by HexRecord.  That class has it's
      # own data access method (also []) and this class should probably use it.
      #
      records = @records.select {|r| r.contains? byte_address, byte_count}
      raise "Access Error: Non-contiguous region" unless HexRecord.contiguous? records
      byte_count = byte_count.to_i(16) if byte_count.is_a? String
      raw_data   = records.map{|r| r.data}.join

      # now pull out just the substring requested
      digit_ix   = 2 * records[0].get_byte_offset(byte_address)
      raw_data[digit_ix, byte_count*2]
   end

   ##
   # Memory write: update one or more HexRecord instances with supplied data.
   #
   # @param [Fixnum] byte_address numeric location in memory of the first byt of data to be
   #    altered by the write operation
   # @param [String] hex_digits Representation of the data as a sequence of hexadecimal
   #   digits. The actual number of bytes is half the length of this string.
   #
   # @raise [RuntimeError] Throws exceptions for all error conditions: data format errors, address errors
   #   internal logic errors. This is part of the riskiest call chain in the app.

   def []=(byte_address, hex_digits)

      # validate memory write access
      raise "Flash is write-protected"   if @unprotected.nil?
      raise "parameter data type error"  unless hex_digits.is_a? String
      raise "Parameter length error"     unless hex_digits.size > 1 && hex_digits.size % 2 == 0
      raise "Out-of-bounds write error"  unless (byte_address >= @unprotected[:start]) &&
                                                (byte_address +
                                                   hex_digits.size/2 <= @unprotected[:stop])

      # Locate the record (or records) that will be altered and verify the data is
      # contiguous. Note that contiguous? only works if records are sorted in ascending
      # address order. We count on this later on.
      bytes_remaining = hex_digits.size / 2
      records         = @records.select {|r| r.contains? byte_address, bytes_remaining}
      raise "Access Error: Non-contiguous region" unless HexRecord.contiguous? records

      # Set up and iterate over the Hex data records to be altered (probably, most often,
      # there is only one, but there could be two or even more). The memory write operation
      # is broken into one assignment statement per Hex record. Assignments take the form
      # of sub-string references (though the actual implementation is handled by the Hex
      # record instance.) This means both the source and destination need a position index
      # and a length. Both sides of the assignment share the same length variable, byte_count.
      # The position variables are, respectively, curr_address and curr_data_ix.
      #
      curr_addr    = byte_address   # position pointer for destination (a HexRecord instance)
      curr_data_ix = 0              # position pointer for source data (hex_digits)
      record_count = 0

      records.each do |rec|
         record_count += 1

         puts "in HexFileWrite with Rec #{record_count}/#{records.size} " +
              "start #{rec.memaddr.to_s(16)} length #{rec.data.size/2}" if $debug

         curr_addr  = rec.memaddr if curr_addr < rec.memaddr           # update to beginning of record
         byte_count = (rec.data.size/2) - (curr_addr - rec.memaddr)    # limit to what rec can supply
         byte_count = bytes_remaining if bytes_remaining < byte_count  # but not more than needed
         rec[curr_addr] = hex_digits[curr_data_ix, 2*byte_count]       # tell rec to update itself

         # and update loop variables
         curr_data_ix    += byte_count * 2
         bytes_remaining -= byte_count
         break unless bytes_remaining > 0
      end

      # Verify all source and destination resources were consumed in the process
      raise "Logic Error: after parameter value assignment, " +
            "#{bytes_remaining} bytes remain (not zero)" unless bytes_remaining == 0
      raise "Logic Error: after parameter value assignment, " +
            "only #{record_count} of #{records.size} records " +
            "were updated" unless record_count == records.size
   end

end # class IntelHexFile
end  # module
